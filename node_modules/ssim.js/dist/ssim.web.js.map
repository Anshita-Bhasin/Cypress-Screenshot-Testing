{"version":3,"sources":["webpack://ssim/webpack/universalModuleDefinition","webpack://ssim/./src/bezkrovnySsim.ts","webpack://ssim/./src/defaults.ts","webpack://ssim/./src/downsample.ts","webpack://ssim/./src/index.ts","webpack://ssim/./src/math.ts","webpack://ssim/./src/matlab/conv2.ts","webpack://ssim/./src/matlab/filter2.ts","webpack://ssim/./src/matlab/fspecial.ts","webpack://ssim/./src/matlab/imfilter.ts","webpack://ssim/./src/matlab/index.ts","webpack://ssim/./src/matlab/internal/numbers.ts","webpack://ssim/./src/matlab/mod.ts","webpack://ssim/./src/matlab/normpdf.ts","webpack://ssim/./src/matlab/ones.ts","webpack://ssim/./src/matlab/padarray.ts","webpack://ssim/./src/matlab/rgb2gray.ts","webpack://ssim/./src/matlab/skip2d.ts","webpack://ssim/./src/matlab/sub.ts","webpack://ssim/./src/matlab/transpose.ts","webpack://ssim/./src/matlab/zeros.ts","webpack://ssim/./src/originalSsim.ts","webpack://ssim/./src/ssim.ts","webpack://ssim/./src/weberSsim.ts","webpack://ssim/webpack/bootstrap","webpack://ssim/webpack/startup"],"names":["root","factory","exports","module","define","amd","self","windowSsim","values1","values2","bitDepth","k1","k2","L","c1","c2","average1","average","average2","σSqx","variance","σSqy","covariance","pixels1","pixels2","options","windowSize","width","Math","ceil","height","data","Array","counter","y","x","windowWidth","min","windowHeight","sub","defaults","downsample","ssim","maxSize","rgb2grayVersion","imageDownsample","pixels","filter","f","imdown","imfilter","skip2d","factor","round","lpf","ones","divide2d","sum2d","originalDownsample","ssimTargets","fast","original","originalSsim","bezkrovny","bezkrovnySsim","weber","weberSsim","getOptions","userOptions","Object","keys","forEach","option","Error","join","validateOptions","image1","image2","start","Date","getTime","ssimMap","comparison","toResize","validateDimensions","rgb2gray","rgb2grayInteger","mssim","undefined","mean2d","ssim_map","performance","xn","sum","length","out","add2dScalar","increase","ref","multiply2d","A","multiplier","multiply2dScalar","ref1","ref2","multiply2dMx","floor","offset","add2dMx","decrease","subtract2dMx","divisor","divide2dScalar","divide2dMx","values","avg","varx","i","cov","mxConv2","b","shape","refWidth","refHeight","cWidth","cHeight","zeros","r1","br1c1","j","reshape","boxConv","a","convn","isBoxKernel","expected","b1","b2","mb","max","nb","temp","c","ma","na","rowStart","colStart","args","h","X","conv2","rotate1802d","_type","hsize","σ","gauss","exp","gaussianFilter2d","size","rangeSquare2d","total","pad","resSize","frows","fcols","padarray","mod","slice","push","padMatrix","getConv2Size","filter2","num","µ","z","numbers","_padval","_direction","padHeight","padWidth","abs","fastPadding","mirrored","B","concat","concatVertical","mirrorVertical","padVertical","concatHorizontal","mirrorHorizonal","padHorizontal","d","uint8Array","Uint8Array","from","array","startRow","everyRow","endRow","startCol","everyCol","endCol","Ai","Aj","w","fspecial","μ1","μ2","μ1Sq","square2d","μ2Sq","μ12","pixels1Sq","pixels2Sq","σ1Sq","subtract2d","σ2Sq","σ12","num1","add2d","num2","denom1","denom2","numerator1","numerator2","denominator1","denominator2","normpdf","getRange","wt","transpose","genSSIM","genUQI","edgeHandler","sumArray","matrixWidth","rightEdge","bottomEdge","bottomRightEdge","partialSumMatrix1","matrixHeight","Int32Array","partialSumMatrix2","data1","data2","windowMatrix","sumMatrix","imageWidth","imageHeight","windows","windowSums","windowVariance","sums","windowSquared","varX","v","mean","sumSquares","squareMeans","windowCovariance","sums1","sums2","covXY","pixels1Rounded","pixels2Rounded","variance1","variance2","ssims","meanx","meany","vary","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","call"],"mappings":"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","file":"ssim.web.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ssim\"] = factory();\n\telse\n\t\troot[\"ssim\"] = factory();\n})(self, function() {\nreturn ","/**\n * Implements Bezkrovny's ssim-specific logic.\n *\n * Refactor of the TypeScript SSIM implementation by Bezkrovny, modified to match the api of ssim.js\n * and reduce duplication.\n *\n * The original work is available at: https://github.com/igor-bezkrovny/image-quantization which is\n * itself a port of the Java SSIM implementation available at https://github.com/rhys-e/structural-similarity\n * both under MIT license\n *\n * @namespace bezkrovnySsim\n */\nimport { average, variance, covariance } from './math'\nimport { sub } from './matlab'\nimport { Options, Matrix } from './types'\n\n/**\n * Generates a SSIM map based on two input image matrices.\n *\n * Images must be a 2-Dimensional grayscale image\n *\n * This method produces a simliar output to `assets/ssim.m` (~1%) when running on Matlab. It's based\n * of Igor Bezkrovny's TypeScript implementation\n *\n * @method bezkrovnySsim\n * @param {Matrix} pixels1 - The reference matrix\n * @param {Matrix} pixels2 - The second matrix to compare against\n * @param {Options} options - The input options parameter\n * @returns {Matrix} ssim_map - A matrix containing the map of computed SSIMs\n * @public\n * @memberOf bezkrovnySsim\n */\nexport function bezkrovnySsim(\n  pixels1: Matrix,\n  pixels2: Matrix,\n  options: Options\n) {\n  const { windowSize } = options\n  const width = Math.ceil(pixels1.width / windowSize)\n  const height = Math.ceil(pixels1.height / windowSize)\n  const data = new Array(width * height)\n  let counter = 0\n\n  for (let y = 0; y < pixels1.height; y += windowSize) {\n    for (let x = 0; x < pixels1.width; x += windowSize) {\n      const windowWidth = Math.min(windowSize, pixels1.width - x)\n      const windowHeight = Math.min(windowSize, pixels1.height - y)\n\n      const values1 = sub(pixels1, x, windowHeight, y, windowWidth)\n      const values2 = sub(pixels2, x, windowHeight, y, windowWidth)\n\n      data[counter++] = windowSsim(values1, values2, options)\n    }\n  }\n  return { data, width, height }\n}\n\n/**\n * Generates the per-window ssim value\n *\n * @method windowSsim\n * @param {Matrix} values1 - The matrix of the ssim window to compute for image 1\n * @param {Matrix} values2 - The matrix of the ssim window to compute for image 2\n * @param {Options} options - The input options parameter\n * @returns {Number} ssim - The ssim value at the current window\n * @private\n * @memberOf bezkrovnySsim\n */\nfunction windowSsim(\n  { data: values1 }: Matrix,\n  { data: values2 }: Matrix,\n  { bitDepth, k1, k2 }: Options\n): number {\n  const L = 2 ** bitDepth - 1\n  const c1 = (k1 * L) ** 2\n  const c2 = (k2 * L) ** 2\n  const average1 = average(values1)\n  const average2 = average(values2)\n  const σSqx = variance(values1, average1)\n  const σSqy = variance(values2, average2)\n  const σxy = covariance(values1, values2, average1, average2)\n\n  const numerator = (2 * average1 * average2 + c1) * (2 * σxy + c2)\n  const denom1 = average1 ** 2 + average2 ** 2 + c1\n  const denom2 = σSqx + σSqy + c2\n\n  return numerator / (denom1 * denom2)\n}\n","import { Options } from './types'\n\nexport const defaults: Options = {\n  windowSize: 11,\n  k1: 0.01,\n  k2: 0.03,\n  bitDepth: 8,\n  downsample: 'original',\n  ssim: 'weber',\n  maxSize: 256,\n  rgb2grayVersion: 'integer',\n}\n","/**\n * Implements downsampling logic\n *\n * @namespace downsample\n */\nimport { divide2d, sum2d } from './math'\nimport { imfilter, ones, skip2d } from './matlab'\nimport { Matrix, Options } from './types'\n\n/**\n * For a given 2D filter `filter`, downsize image `pixels` by a factor of `f`.\n *\n * @method imageDownsample\n * @param {Matrix} pixels - The matrix to downsample\n * @param {Matrix} filter - The filter to convolve the image with\n * @param {number} f - The downsampling factor (`image size / f`)\n * @returns {Matrix} imdown - The downsampled, filtered image\n * @private\n * @memberOf downsample\n */\nfunction imageDownsample(pixels: Matrix, filter: Matrix, f: number): Matrix {\n  const imdown = imfilter(pixels, filter, 'symmetric', 'same')\n\n  return skip2d(imdown, [0, f, imdown.height], [0, f, imdown.width])\n}\n\n/**\n * Downsamples images greater than `maxSize` pixels on the smallest direction. If neither image\n * exceeds these dimensions they are returned as they are.\n *\n * It replicates the same logic than the original matlab scripts\n *\n * @method originalDownsample\n * @param {Matrix} pixels1 - The first matrix to downsample\n * @param {Matrix} pixels2 - The second matrix to downsample\n * @param {number} [maxSize=256] - The maximum size on the smallest dimension\n * @returns {[Matrix, Matrix]} ssim_map - A matrix containing the map of computed SSIMs\n * @private\n * @memberOf downsample\n */\nfunction originalDownsample(\n  pixels1: Matrix,\n  pixels2: Matrix,\n  maxSize = 256\n): [Matrix, Matrix] {\n  const factor = Math.min(pixels1.width, pixels2.height) / maxSize\n  const f = Math.round(factor)\n\n  if (f > 1) {\n    let lpf = ones(f)\n\n    lpf = divide2d(lpf, sum2d(lpf))\n\n    pixels1 = imageDownsample(pixels1, lpf, f)\n    pixels2 = imageDownsample(pixels2, lpf, f)\n  }\n\n  return [pixels1, pixels2]\n}\n\n/**\n * Determines the downsizing algorithm to implement (if any) to the reference and target images\n *\n * @method downsample\n * @param {[Matrix, Matrix]} pixels - The first and second matrices to downsample\n * @param {Object} options - The inputs options object\n * @returns {[Matrix, Matrix]} pixels - An array containing the 2 downsized images\n * @public\n * @memberOf downsample\n */\nexport function downsample(\n  pixels: [Matrix, Matrix],\n  options: Options\n): [Matrix, Matrix] {\n  if (options.downsample === 'original') {\n    return originalDownsample(pixels[0], pixels[1], options.maxSize)\n  }\n  // else if options.downsample === 'fast' -> the image is downsampled when read (readpixels.js)\n  // else do not downsample\n  return pixels\n}\n","/**\n * SSIM External API\n *\n * @module main\n */\nimport { rgb2gray, rgb2grayInteger } from './matlab'\nimport { mean2d } from './math'\nimport { ssim as fastSsim } from './ssim'\nimport { originalSsim } from './originalSsim'\nimport { bezkrovnySsim } from './bezkrovnySsim'\nimport { downsample } from './downsample'\nimport { defaults } from './defaults'\nimport {\n  Options,\n  Images,\n  Matrices,\n  Matrix,\n  MSSIMMatrix,\n  ImageData,\n} from './types'\nimport { weberSsim } from './weberSsim'\n\nexport { Options, Matrix }\n\nconst ssimTargets = {\n  fast: fastSsim,\n  original: originalSsim,\n  bezkrovny: bezkrovnySsim,\n  weber: weberSsim,\n}\n\nfunction validateOptions(options: Options) {\n  Object.keys(options).forEach((option) => {\n    if (!(option in defaults)) {\n      throw new Error(`\"${option}\" is not a valid option`)\n    }\n  })\n  if ('k1' in options && (typeof options.k1 !== 'number' || options.k1 < 0)) {\n    throw new Error(`Invalid k1 value. Default is ${defaults.k1}`)\n  }\n  if ('k2' in options && (typeof options.k2 !== 'number' || options.k2 < 0)) {\n    throw new Error(`Invalid k2 value. Default is ${defaults.k2}`)\n  }\n  if (!(options.ssim in ssimTargets)) {\n    throw new Error(\n      `Invalid ssim option (use: ${Object.keys(ssimTargets).join(', ')})`\n    )\n  }\n}\n\nexport function getOptions(userOptions?: Partial<Options>): Options {\n  const options = { ...defaults, ...userOptions }\n\n  validateOptions(options)\n\n  return options\n}\n\nfunction validateDimensions([pixels1, pixels2, options]: Images): Images {\n  if (pixels1.width !== pixels2.width || pixels1.height !== pixels2.height) {\n    throw new Error('Image dimensions do not match')\n  }\n\n  return [pixels1, pixels2, options]\n}\n\nfunction toGrayScale([pixels1, pixels2, options]: Images): Matrices {\n  if (options.rgb2grayVersion === 'original') {\n    return [rgb2gray(pixels1), rgb2gray(pixels2), options]\n  } else {\n    return [rgb2grayInteger(pixels1), rgb2grayInteger(pixels2), options]\n  }\n}\n\nfunction toResize([pixels1, pixels2, options]: Matrices): Matrices {\n  const pixels = downsample([pixels1, pixels2], options)\n\n  return [pixels[0], pixels[1], options]\n}\n\nfunction comparison([pixels1, pixels2, options]: Matrices): Matrix {\n  return ssimTargets[options.ssim](pixels1, pixels2, options)\n}\n\n/**\n * @method ssim - The ssim method. You can call the package directly or through the `ssim` property.\n * @public\n * @example import mod = from 'ssim.js';\n * mod(imgBuffer1, imgBuffer2);\n * mod.ssim(imgBuffer1, imgBuffer2);\n */\nexport function ssim(\n  image1: ImageData,\n  image2: ImageData,\n  userOptions?: Partial<Options>\n): {\n  ssim_map: Matrix\n  mssim: number\n  performance: number\n} {\n  const start = new Date().getTime()\n  const options = getOptions(userOptions)\n  const ssimMap = comparison(\n    toResize(toGrayScale(validateDimensions([image1, image2, options])))\n  )\n  const mssim =\n    (ssimMap as MSSIMMatrix).mssim !== undefined\n      ? (ssimMap as MSSIMMatrix).mssim\n      : mean2d(ssimMap)\n  return {\n    mssim,\n    ssim_map: ssimMap,\n    performance: new Date().getTime() - start,\n  }\n}\n\nexport default ssim\n","/**\n * Generates all basic arithmetic and matrix computations required\n *\n * Most of these methods use plain for loops and reduce nested calls. This results in about ~100x\n * improvement on SSIM computation for 512x512 images on recent versions of node (~v6.7) over\n * implementations using map or reduce.\n *\n * @namespace math\n */\nimport { Matrix } from './types'\n\n/**\n * Computes the mean value of a given array. It is the sum of a list of numbers divided by the\n * number of numbers in the list.\n *\n * @method average\n * @param {Number[]} xn - The target array\n * @returns {Number} average - The mean value of all elements within the array\n * @public\n * @memberOf math\n * @since 0.0.1\n */\nexport function average(xn: number[]): number {\n  return sum(xn) / xn.length\n}\n\n/**\n * Computes the sum of a given array. It adds all values within the array and returns the total\n *\n * @method sum\n * @param {Number[]} xn - The target array\n * @returns {Number} sum - The total value\n * @private\n * @memberOf math\n * @since 0.0.1\n */\nexport function sum(xn: number[]): number {\n  let out = 0\n\n  for (let x = 0; x < xn.length; x++) {\n    out += xn[x]\n  }\n  return out\n}\n\n/**\n * Computes the largest integer less than or equal to a given number for each member of a given\n * array.\n *\n * @method floor\n * @param {Number[]} xn - The target array\n * @returns {Number[]} floorArr - An array with the Math.floor value for each element of the target\n * array\n * @private\n * @memberOf math\n * @since 0.0.1\n */\nexport function floor(xn: number[]): number[] {\n  const out = new Array(xn.length)\n\n  for (let x = 0; x < xn.length; x++) {\n    out[x] = Math.floor(xn[x])\n  }\n\n  return out\n}\n\n/**\n * Computes the sum of all elements within a matrix\n *\n * @method sum2d\n * @param {Matrix} A - The input matrix\n * @returns {Number} sum - The total value of adding each cell\n * @public\n * @memberOf math\n * @since 0.0.2\n */\nexport function sum2d({ data }: Matrix): number {\n  let out = 0\n\n  for (let x = 0; x < data.length; x++) {\n    out += data[x]\n  }\n\n  return out\n}\n\n/**\n * Adds values of two matrices of the same size\n *\n * @method add2dMx\n * @param {Matrix} A - The first input matrix\n * @param {Matrix} B - The second input matrix\n * @returns {Matrix} out - A matrix with a cell-by-cell sum of `A` and `B`\n * @private\n * @memberOf math\n * @since 0.0.2\n */\nfunction add2dMx(\n  { data: ref1, width, height }: Matrix,\n  { data: ref2 }: Matrix\n): Matrix {\n  const data = new Array(ref1.length)\n\n  for (let x = 0; x < height; x++) {\n    const offset = x * width\n\n    for (let y = 0; y < width; y++) {\n      data[offset + y] = ref1[offset + y] + ref2[offset + y]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Subtracts values of second matrix from the first one. It assumes both matrices are of the same\n * size\n *\n * @method subtract2dMx\n * @param {Matrix} A - The first input matrix\n * @param {Matrix} B - The second input matrix\n * @returns {Matrix} out - A matrix with a cell-by-cell subtraction of `A` minus `B`\n * @private\n * @memberOf math\n * @since 0.0.2\n */\nfunction subtract2dMx(\n  { data: ref1, width, height }: Matrix,\n  { data: ref2 }: Matrix\n): Matrix {\n  const data = new Array(ref1.length)\n\n  for (let x = 0; x < height; x++) {\n    const offset = x * width\n\n    for (let y = 0; y < width; y++) {\n      data[offset + y] = ref1[offset + y] - ref2[offset + y]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Adds a constant value two each matrix cell\n *\n * @method add2dScalar\n * @param {Matrix} A - The first input matrix\n * @param {Number} increase - The value to add\n * @returns {Matrix} B - The cell-by-cell matrix sum of `A` and `increase`\n * @private\n * @memberOf math\n * @since 0.0.2\n */\nfunction add2dScalar(\n  { data: ref, width, height }: Matrix,\n  increase: number\n): Matrix {\n  const data = new Array(ref.length)\n\n  for (let x = 0; x < ref.length; x++) {\n    data[x] = ref[x] + increase\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Adds values of two matrices of the same size or a matrix and a constant\n *\n * @method add2d\n * @param {Matrix} A - The first input matrix\n * @param {Matrix|Number} increase - The second input matrix or the constant value\n * @returns {Matrix} B - A matrix with a cell-by-cell sum of the first and second parameters\n * @public\n * @memberOf math\n * @since 0.0.2\n */\nexport function add2d(A: Matrix, increase: Matrix | number): Matrix {\n  if (typeof increase === 'number') {\n    return add2dScalar(A, increase)\n  }\n  return add2dMx(A, increase)\n}\n\n/**\n * Subtracts values of two matrices of the same size or a matrix and a constant\n *\n * @method subtract2d\n * @param {Matrix} A - The first input matrix\n * @param {Matrix|Number} decrease - The second input matrix or the constant value\n * @returns {Matrix} B - A matrix with a cell-by-cell subtraction of the first parameter minus the\n * second one\n * @public\n * @memberOf math\n */\nexport function subtract2d(A: Matrix, decrease: Matrix | number): Matrix {\n  if (typeof decrease === 'number') {\n    return add2dScalar(A, -decrease)\n  }\n  return subtract2dMx(A, decrease)\n}\n\n/**\n * Divides each matrix cell by a constant value\n *\n * @method divide2dScalar\n * @param {Matrix} A - The first input matrix\n * @param {Number} divisor - The value to divide by\n * @returns {Matrix} B - The cell-by-cell matrix divison of `A` and `divisor`\n * @private\n * @memberOf math\n * @since 0.0.2\n */\nfunction divide2dScalar(\n  { data: ref, width, height }: Matrix,\n  divisor: number\n): Matrix {\n  const data = new Array(ref.length)\n\n  for (let x = 0; x < ref.length; x++) {\n    data[x] = ref[x] / divisor\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Divides, cell-by-cell, values of two matrices of the same size\n *\n * @method divide2dMx\n * @param {Matrix} A - The first input matrix\n * @param {Matrix} B - The second input matrix\n * @returns {Matrix} out - A matrix with a cell-by-cell division of `A`/`B`\n * @private\n * @memberOf math\n * @since 0.0.2\n */\nfunction divide2dMx(\n  { data: ref1, width, height }: Matrix,\n  { data: ref2 }: Matrix\n): Matrix {\n  const data = new Array(ref1.length)\n\n  for (let x = 0; x < ref1.length; x++) {\n    data[x] = ref1[x] / ref2[x]\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Divides values of two matrices of the same size or between a matrix and a constant\n *\n * @method divide2d\n * @param {Matrix} A - The first input matrix\n * @param {Matrix|Number} divisor - The second input matrix or the constant value\n * @returns {Matrix} B - A matrix with the cell-by-cell division of the first and second parameters\n * @public\n * @memberOf math\n * @since 0.0.2\n */\nexport function divide2d(A: Matrix, divisor: Matrix | number): Matrix {\n  if (typeof divisor === 'number') {\n    return divide2dScalar(A, divisor)\n  }\n  return divide2dMx(A, divisor)\n}\n\n/**\n * Multiplies each matrix cell by a constant value\n *\n * @method multiply2dScalar\n * @param {Matrix} A - The first input matrix\n * @param {Number} multiplier - The value to multiply each cell with\n * @returns {Matrix} B - The cell-by-cell matrix multiplication of `A` and `multiplier`\n * @private\n * @memberOf math\n * @since 0.0.2\n */\nfunction multiply2dScalar(\n  { data: ref, width, height }: Matrix,\n  multiplier: number\n): Matrix {\n  const data = new Array(ref.length)\n\n  for (let x = 0; x < ref.length; x++) {\n    data[x] = ref[x] * multiplier\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Multiplies, cell-by-cell, values of two matrices of the same size\n *\n * @method multiply2dMx\n * @param {Matrix} A - The first input matrix\n * @param {Matrix} B - The second input matrix\n * @returns {Matrix} out - A matrix with a cell-by-cell multiplication of `A` * `B`\n * @private\n * @memberOf math\n * @since 0.0.2\n */\nfunction multiply2dMx(\n  { data: ref1, width, height }: Matrix,\n  { data: ref2 }: Matrix\n): Matrix {\n  const data = new Array(ref1.length)\n\n  for (let x = 0; x < ref1.length; x++) {\n    data[x] = ref1[x] * ref2[x]\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Multiplies values of two matrices of the same size or between a matrix and a constant\n *\n * @method multiply2d\n * @param {Matrix} A - The first input matrix\n * @param {Matrix|Number} multiplier - The second input matrix or the constant value\n * @returns {Matrix} out - A matrix with the cell-by-cell multiplication of the first and second\n * parameters\n * @public\n * @memberOf math\n * @since 0.0.2\n */\nexport function multiply2d(A: Matrix, multiplier: Matrix | number): Matrix {\n  if (typeof multiplier === 'number') {\n    return multiply2dScalar(A, multiplier)\n  }\n  return multiply2dMx(A, multiplier)\n}\n\n/**\n * Generates the cell-by-cell square value of a target matrix\n *\n * @method square2d\n * @param {Matrix} A - The target matrix\n * @returns {Matrix} B - A matrix with squared value of each cell\n * @public\n * @memberOf math\n * @since 0.0.2\n */\nexport function square2d(A: Matrix): Matrix {\n  return multiply2d(A, A)\n}\n\n/**\n * Calculates the total mean value for a given matrix\n *\n * @method mean2d\n * @param {Matrix} A - The target matrix\n * @returns {Number} mean - The total mean of each cell\n * @public\n * @memberOf math\n * @since 0.0.2\n */\nexport function mean2d(A: Matrix): number {\n  return sum2d(A) / A.data.length\n}\n\n/**\n * Computes the variance for a given array\n *\n * @method variance\n * @param {Array<Number>} values - The target array\n * @param {Number} [avg=average(values)] - If specified, it will use this values as the average of\n * the array values. If not, it will compute the actual average\n * @returns {Number} varx - The resulting variance value\n * @public\n * @memberOf math\n */\nexport function variance(\n  values: number[],\n  avg: number = average(values)\n): number {\n  let varx = 0\n  let i = values.length\n\n  while (i--) {\n    varx += (values[i] - avg) ** 2\n  }\n\n  return varx / values.length\n}\n\n/**\n * Computes the covariance between 2 arrays\n *\n * @method covariance\n * @param {Array<Number>} values1 - The first target array\n * @param {Array<Number>} values2 - The second target array\n * @param {Number} [average1=average(values)] - If specified, it will use this values as the average\n * of the first array. If not, it will compute the actual average\n * @param {Number} [average2=average(values)] - If specified, it will use this values as the average\n * of the second array. If not, it will compute the actual average\n * @returns {Number} cov - The resulting covariance\n * @public\n * @memberOf math\n */\nexport function covariance(\n  values1: number[],\n  values2: number[],\n  average1: number = average(values1),\n  average2: number = average(values2)\n): number {\n  let cov = 0\n  let i = values1.length\n\n  while (i--) {\n    cov += (values1[i] - average1) * (values2[i] - average2)\n  }\n\n  return cov / values1.length\n}\n","import { multiply2d } from '../math'\nimport { ones } from './ones'\nimport { sub } from './sub'\nimport { zeros } from './zeros'\nimport { Matrix, Shape } from '../types'\n\n/**\n * `C = conv2(a,b)` computes the two-dimensional convolution of matrices `a` and `b`. If one of\n * these matrices describes a two-dimensional finite impulse response (FIR) filter, the other matrix\n * is filtered in two dimensions. The size of `c` is determined as follows:\n *\n * ```\n * if [ma,na] = size(a), [mb,nb] = size(b), and [mc,nc] = size(c), then\n * mc = max([ma+mb-1,ma,mb]) and nc = max([na+nb-1,na,nb]).\n * ```\n *\n * `shape` returns a subsection of the two-dimensional convolution, based on one of these values for\n * the parameter:\n *\n * - **full**: Returns the full two-dimensional convolution (default).\n * - **same**: Returns the central part of the convolution of the same size as `a`.\n * - **valid**: Returns only those parts of the convolution that are computed without the\n *   zero-padded edges. Using this option, `size(c) === max([ma-max(0,mb-1),na-max(0,nb-1)],0)`\n *\n * @method mxConv2\n * @param {Matrix} a - The first matrix\n * @param {Matrix} b - The second matrix\n * @param {String} [shape='full'] - One of 'full' / 'same' / 'valid'\n * @returns {Matrix} c - Returns the convolution filtered by `shape`\n * @private\n * @memberOf matlab\n */\nfunction mxConv2(\n  { data: ref, width: refWidth, height: refHeight }: Matrix,\n  b: Matrix,\n  shape: Shape = 'full'\n): Matrix {\n  const cWidth = refWidth + b.width - 1\n  const cHeight = refHeight + b.height - 1\n  const { data } = zeros(cHeight, cWidth)\n\n  /**\n   * Computing the convolution is the most computentionally intensive task for SSIM and we do it\n   * several times.\n   *\n   * This section has been optimized for performance and readability suffers.\n   */\n  for (let r1 = 0; r1 < b.height; r1++) {\n    for (let c1 = 0; c1 < b.width; c1++) {\n      const br1c1 = b.data[r1 * b.width + c1]\n\n      if (br1c1) {\n        for (let i = 0; i < refHeight; i++) {\n          for (let j = 0; j < refWidth; j++) {\n            data[(i + r1) * cWidth + j + c1] += ref[i * refWidth + j] * br1c1\n          }\n        }\n      }\n    }\n  }\n\n  const c = {\n    data,\n    width: cWidth,\n    height: cHeight,\n  }\n\n  return reshape(c, shape, refHeight, b.height, refWidth, b.width)\n}\n\n/**\n * `C = boxConv(a,b)` computes the two-dimensional convolution of a matrix `a` and box kernel `b`.\n *\n * The `shape` parameter returns a subsection of the two-dimensional convolution as defined by\n * mxConv2.\n *\n * @method boxConv\n * @param {Matrix} a - The first matrix\n * @param {Matrix} b - The box kernel\n * @param {String} [shape='full'] - One of 'full' / 'same' / 'valid'\n * @returns {Matrix} c - Returns the convolution filtered by `shape`\n * @private\n * @memberOf matlab\n */\nfunction boxConv(\n  a: Matrix,\n  { data, width, height }: Matrix,\n  shape: Shape = 'full'\n): Matrix {\n  const b1 = ones(height, 1)\n  const b2 = ones(1, width)\n  const out = convn(a, b1, b2, shape)\n\n  return multiply2d(out, data[0])\n}\n\n/**\n * Determines whether all values in an array are the same so that the kernel can be treated as a box\n * kernel\n *\n * @method isBoxKernel\n * @param {Matrix} a - The input matrix\n * @returns {Boolean} boxKernel - Returns true if all values in the matrix are the same, false\n * otherwise\n * @private\n * @memberOf matlab\n */\nfunction isBoxKernel({ data }: Matrix): boolean {\n  const expected = data[0]\n\n  for (let i = 1; i < data.length; i++) {\n    if (data[i] !== expected) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * `C = convn(a,b1, b2)` computes the two-dimensional convolution of matrices `a.*b1.*b2`.\n *\n * The size of `c` is determined as follows:\n *\n * ```\n * if [ma,na] = size(a), [mb] = size(b1), [nb] = size(b2) and [mc,nc] = size(c), then\n * mc = max([ma+mb-1,ma,mb]) and nc = max([na+nb-1,na,nb]).\n * ```\n *\n * `shape` returns a section of the two-dimensional convolution, based on one of these values for\n * the parameter:\n *\n * - **full**: Returns the full two-dimensional convolution (default).\n * - **same**: Returns the central part of the convolution of the same size as `a`.\n * - **valid**: Returns only those parts of the convolution that are computed without the\n *   zero-padded edges. Using this option, `size(c) === max([ma-max(0,mb-1),na-max(0,nb-1)],0)`\n *\n * This method mimics Matlab's `convn` method but limited to 2 1 dimensional kernels.\n *\n * @method convn\n * @param {Matrix} a - The first matrix\n * @param {Matrix} b1 - The first 1-D kernel\n * @param {Matrix} b2 - The second 1-D kernel\n * @param {String} [shape='full'] - One of 'full' / 'same' / 'valid'\n * @returns {Matrix} c - Returns the convolution filtered by `shape`\n * @private\n * @memberOf matlab\n */\nfunction convn(\n  a: Matrix,\n  b1: Matrix,\n  b2: Matrix,\n  shape: Shape = 'full'\n): Matrix {\n  const mb = Math.max(b1.height, b1.width)\n  const nb = Math.max(b2.height, b2.width)\n  const temp = mxConv2(a, b1, 'full')\n  const c = mxConv2(temp, b2, 'full')\n\n  return reshape(c, shape, a.height, mb, a.width, nb)\n}\n\n/**\n * `reshape` crops the resulting convolution matrix to match the values specified in `shape`.\n *\n * - **full**: Returns the input\n * - **same**: Returns the central part of the convolution of the same size as `a`.\n * - **valid**: Returns only those parts of the convolution that are computed without the\n *   zero-padded edges\n *\n * @method reshape\n * @param {Matrix} c - The output matrix\n * @param {String} shape - One of 'full' / 'same' / 'valid'\n * @param {Number} ma - The number of rows of the input matrix\n * @param {Number} mb - The number of rows of the input filter\n * @param {Number} na - The number of columns of the input matrix\n * @param {Number} nb - The number of columns of the input filter\n * @returns {Matrix} c - Returns the input convolution filtered by `shape`\n * @private\n * @memberOf matlab\n */\nfunction reshape(\n  c: Matrix,\n  shape: Shape,\n  ma: number,\n  mb: number,\n  na: number,\n  nb: number\n): Matrix {\n  if (shape === 'full') {\n    return c\n  } else if (shape === 'same') {\n    const rowStart = Math.ceil((c.height - ma) / 2)\n    const colStart = Math.ceil((c.width - na) / 2)\n\n    return sub(c, rowStart, ma, colStart, na)\n  }\n\n  return sub(c, mb - 1, ma - mb + 1, nb - 1, na - nb + 1)\n}\n\n/**\n * `C = conv2(a,b)` computes the two-dimensional convolution of matrices `a` and `b`. If one of\n * these matrices describes a two-dimensional finite impulse response (FIR) filter, the other matrix\n * is filtered in two dimensions.\n *\n * The size of `c` is determined as follows:\n *\n * ```\n * if [ma,na] = size(a), [mb,nb] = size(b), and [mc,nc] = size(c), then\n * mc = max([ma+mb-1,ma,mb]) and nc = max([na+nb-1,na,nb]).\n * ```\n *\n * `shape` returns a subsection of the two-dimensional convolution, based on one of these values for\n * the parameter:\n *\n * - **full**: Returns the full two-dimensional convolution (default).\n * - **same**: Returns the central part of the convolution of the same size as `a`.\n * - **valid**: Returns only those parts of the convolution that are computed without the\n *   zero-padded edges. Using this option, `size(c) === max([ma-max(0,mb-1),na-max(0,nb-1)],0)`\n *\n * Alternatively, 2 1-D filters may be provided as parameters, following the format:\n * `conv2(a, b1, b2, shape)`. This is similar to Matlab's implementation allowing any number of 1-D\n * filters to be applied but limited to 2\n *\n * This method mimics Matlab's `conv2` method.\n *\n * Given:\n * const A = rand(3);\n * const B = rand(4);\n *\n * @example conv2(A,B); // output is 6-by-6\n * {\n *   data: [\n *     0.1838, 0.2374, 0.9727, 1.2644, 0.7890, 0.3750,\n *     0.6929, 1.2019, 1.5499, 2.1733, 1.3325, 0.3096,\n *     0.5627, 1.5150, 2.3576, 3.1553, 2.5373, 1.0602,\n *     0.9986, 2.3811, 3.4302, 3.5128, 2.4489, 0.8462,\n *     0.3089, 1.1419, 1.8229, 2.1561, 1.6364, 0.6841,\n *     0.3287, 0.9347, 1.6464, 1.7928, 1.2422, 0.5423\n *   ],\n *   width: 6,\n *   height: 6\n * }\n *\n * @example conv2(A,B,'same') => // output is the same size as A: 3-by-3\n * {\n *   data: [\n *     2.3576, 3.1553, 2.5373,\n *     3.4302, 3.5128, 2.4489,\n *     1.8229, 2.1561, 1.6364\n *   ],\n *   width: 3,\n *   height: 3\n * }\n *\n * @method conv2\n * @param {Array} args - The list of arguments, see `mxConv2` and `convn` for the exact parameters\n * @returns {Matrix} c - Returns the convolution filtered by `shape`\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function conv2(\n  ...args: Parameters<typeof boxConv | typeof convn | typeof mxConv2>\n) {\n  if (args[2] && (args[2] as Matrix).data) {\n    return convn(...(args as Parameters<typeof convn>))\n  } else if (isBoxKernel(args[1])) {\n    return boxConv(...(args as Parameters<typeof boxConv>))\n  }\n  return mxConv2(...(args as Parameters<typeof mxConv2>))\n}\n","import { conv2 } from './conv2'\nimport { Matrix, Shape } from '../types'\n\n/**\n * Rotates a matrix 180deg.\n *\n * @example\n * 1 2 3 4  becomes:  8 7 6 5\n * 5 6 7 8            4 3 2 1\n *\n * @method rotate1802d\n * @param {Matrix} mx - The input matrix\n * @returns {Matrix} out - The rotated matrix\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction rotate1802d({ data: ref, width, height }: Matrix): Matrix {\n  const data = new Array(ref.length)\n\n  for (let i = 0; i < height; i++) {\n    for (let j = 0; j < width; j++) {\n      data[i * width + j] = ref[(height - 1 - i) * width + width - 1 - j]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Given a matrix X and a two-dimensional FIR filter h, filter2 rotates your filter matrix 180\n * degrees to create a convolution kernel. It then calls conv2, the two-dimensional convolution\n * function, to implement the filtering operation.\n *\n * This method mimics Matlab's `filter2` method\n *\n * @method filter2\n * @param {Matrix} h - The FIR filter\n * @param {Matrix} X - The input matrix\n * @param string [shape='same'] - The convolution shape\n * @returns {Matrix} conv - The 2D convolution of X with h\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function filter2(h: Matrix, X: Matrix, shape: Shape = 'same'): Matrix {\n  return conv2(X, rotate1802d(h), shape)\n}\n","import { Matrix } from '../types'\nimport { sum2d, divide2d } from '../math'\n\n/**\n * Creates a matrix of lenght `2 * length + 1` with values being the sum of the square of the\n * distance for each component from the center. E.g:\n *\n * For a length of 5 it results in a matrix size of 11. Looking at [0, 0] (distance: [-5, -5] from\n * the center), the value at that position becomes `-5^2 + -5^2 = 50`\n *\n * @method rangeSquare2d\n * @param {Number} length - The maxium distance from the matrix center\n * @returns {Matrix} mx - The generated matrix\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction rangeSquare2d(length: number): Matrix {\n  const size = length * 2 + 1\n  const data = new Array(size ** 2)\n\n  for (let x = 0; x < size; x++) {\n    for (let y = 0; y < size; y++) {\n      data[x * size + y] = (x - length) ** 2 + (y - length) ** 2\n    }\n  }\n\n  return {\n    data,\n    width: size,\n    height: size,\n  }\n}\n\n/**\n * Applies a gaussian filter of sigma to a given matrix\n *\n * @method gaussianFilter2d\n * @param {Matrix} A - The input matrix\n * @param {Number} σ - The sigma value\n * @returns {Matrix} B - The matrix with the gaussian filter applied\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction gaussianFilter2d(\n  { data: ref, width, height }: Matrix,\n  σ: number\n): Matrix {\n  const data = new Array(ref.length)\n\n  for (let x = 0; x < ref.length; x++) {\n    data[x] = Math.exp(-ref[x] / (2 * σ ** 2))\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n/**\n * Create predefined 2-D filter\n *\n * `h = fspecial(type, parameters)` accepts the filter specified by type plus additional modifying\n * parameters particular to the type of filter chosen. If you omit these arguments, fspecial uses\n * default values for the parameters.\n *\n * This method mimics Matlab's `fspecial2` method with `type = 'gaussian'`. `hsize` cannot be a\n * vector (unlike Matlab's implementation), only a Number is accepted.\n *\n * `h = fspecial('gaussian', hsize, sigma)` returns a rotationally symmetric Gaussian lowpass filter\n * of size `hsize` with standard deviation sigma (positive). In this implementation `hsize` will\n * always be a scalar, which will result in `h` being a square matrix.\n *\n * The gaussian logic follows: hg(hsize) = e^(-2*hsize^2 / 2σ^2)\n *\n * @example\n *   fspecial('gaussian', 3, 1.5) === {\n *     data: [\n *       0.094742, 0.118318, 0.094742,\n *       0.118318, 0.147761, 0.118318,\n *       0.094742, 0.118318, 0.094742\n *     ],\n *     width: 3,\n *     height: 3\n *   };\n *\n * @method fspecial\n * @param {String} [type='gaussian'] - The type of 2D filter to create (coerced to 'gaussian')\n * @param {Number} [hsize=3] - The length of the filter\n * @param {Number} [σ=1.5] - The filter sigma value\n * @returns {Matrix} c - Returns the central part of the convolution of the same\n * size as `a`.\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function fspecial(_type?: 'gaussian', hsize = 3, σ = 1.5): Matrix {\n  hsize = (hsize - 1) / 2\n\n  const pos = rangeSquare2d(hsize)\n  const gauss = gaussianFilter2d(pos, σ)\n  const total = sum2d(gauss)\n\n  return divide2d(gauss, total)\n}\n","import { mod } from './mod'\nimport { padarray, PaddingValue } from './padarray'\nimport { floor } from '../math'\nimport { filter2 } from './filter2'\nimport { Matrix, Shape } from '../types'\n\n/**\n * Adds padding to input matrix A\n *\n * @method padMatrix\n * @param {Matrix} A - The target matrix\n * @param {Number} frows - The number of rows in the filter\n * @param {Number} fcols - The number of columns in the filter\n * @param {String} pad - The type of padding to apply\n * @param {Matrix} B - The padded input matrix\n * @private\n * @memberOf matlab\n */\nfunction padMatrix(\n  A: Matrix,\n  frows: number,\n  fcols: number,\n  pad: PaddingValue\n): Matrix {\n  A = padarray(A, floor([frows / 2, fcols / 2]) as [number, number], pad)\n  if (mod(frows, 2) === 0) {\n    // remove the last row\n    A.data = A.data.slice(0, -A.width)\n    A.height--\n  }\n  if (mod(fcols, 2) === 0) {\n    // remove the last column\n    const data = []\n\n    for (let x = 0; x < A.data.length; x++) {\n      if ((x + 1) % A.width !== 0) {\n        data.push(A.data[x])\n      }\n    }\n    A.data = data\n    A.width--\n  }\n  return A\n}\n\n/**\n * Gets the `shape` parameter for `conv2` based on the `resSize` parameter for `imfilter`. In most\n * cases they are equivalent except for when `resSize` equals \"same\" which is converted to \"valid\".\n *\n * @method getConv2Size\n * @param {String} resSize - The format to use for the `imfilter` call\n * @returns {String} shape - The shape value to use for `conv2`\n * @private\n * @memberOf matlab\n */\nfunction getConv2Size(resSize: Shape): Shape {\n  if (resSize === 'same') {\n    resSize = 'valid'\n  }\n  return resSize\n}\n\n/**\n * `B = imfilter(A,f)` filters a 2-dimensional array `A` with the 2-dimensional filter `f`. The\n * result `B` has the same size as `A`.\n *\n * `imfilter` computes each element of the output, `B`. If `A` is an integer, `imfilter` will not\n * truncate the output elements that exceed the range, and it will not round fractional values.\n *\n * This method mimics Matlab's `imfilter` method with `padval = 'symmetric'` without integer\n * rounding. No other options have been implemented and, if set, they will be ignored.\n *\n * @method imfilter\n * @param {Matrix} A - The target matrix\n * @param {Matrix} f - The filter to apply\n * @param {String} [pad=\"symmetric\"] - The type of padding. Only \"symmetric\" is implemented\n * @param {String} [resSize=\"same\"] - The format to use for the filter size. Valid values are:\n * \"same\", \"valid\" and \"full\"\n * @returns {Matrix} B - The filtered array\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function imfilter(\n  A: Matrix,\n  f: Matrix,\n  pad: PaddingValue = 'symmetric',\n  resSize: Shape = 'same'\n) {\n  A = padMatrix(A, f.width, f.height, pad)\n  resSize = getConv2Size(resSize)\n  return filter2(f, A, resSize)\n}\n","/**\n * Implements Matlab functions or functionality.\n *\n * The goal here is not a perfect reproduction of matlab logic but just a minimal implementation\n * needed to correctly reproduce the SSIM matlab script.\n *\n * That means that functionality used will be implemented but additional / unused parameters will\n * not.\n *\n * @namespace matlab\n */\nexport * from './conv2'\nexport * from './filter2'\nexport * from './fspecial'\nexport * from './imfilter'\nexport * from './normpdf'\nexport * from './ones'\nexport * from './padarray'\nexport * from './rgb2gray'\nexport * from './skip2d'\nexport * from './sub'\nexport * from './transpose'\nexport * from './zeros'\n","import { Matrix } from '../../types'\n\n/**\n * Create a matrix with each cell with the value of `num`\n *\n * @method numbers\n * @param {Number} height - The number of rows\n * @param {Number} width - The number of columns\n * @param {Number} num - The value to set on each cell\n * @returns {Matrix} B - An n-by-m matrix of `num`\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function numbers(height: number, width: number, num: number): Matrix {\n  const size = width * height\n  const data = new Array(size)\n\n  for (let x = 0; x < size; x++) {\n    data[x] = num\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n","/**\n * `M = mod(X,Y)` returns the remainder `X - Y.*floor(X./Y)` for nonzero `Y`, and returns `X`\n * otherwise. `mod(X,Y)` always differs from `X` by a multiple of `Y`.\n *\n * So long as operands `X` and `Y` are of the same sign, the function `mod(X,Y)` returns the same\n * result as does `rem(X,Y)`. However, for positive `X` and `Y`, `mod(-x,y) = rem(-x,y)+y`.\n *\n * The mod function is useful for congruence relationships: x and y are congruent (mod m) if and\n * only if mod(x,m) == mod(y,m).\n *\n * This method mimics Matlab's `mod` method\n *\n * @method mod\n * @param {Number} x - The dividend\n * @param {Numvwe} y - The divisor\n * @returns {Number} M - Returns the signed remainder after division.\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function mod(x: number, y: number): number {\n  return x - y * Math.floor(x / y)\n}\n","import { Matrix } from '../types'\n\n/**\n * `Y = normpdf(X,μ,σ)` computes the pdf at each of the values in `X` using the normal\n * distribution with mean `μ` and standard deviation `σ`. `X`, `μ`, and `σ` can be vectors,\n * matrices, or multidimensional arrays that all have the same size. A scalar input is expanded to a\n * constant array with the same dimensions as the other inputs. The parameters in `σ` must be\n * positive.\n *\n * The normal pdf is: `y = f(x|μ,σ) = (1 / (σ√(2π))) * e^(-(x-μ)^2/2σ^2)`\n *\n * The likelihood function is the pdf viewed as a function of the parameters. Maximum likelihood\n * estimators (MLEs) are the values of the parameters that maximize the likelihood function for a\n * fixed value of `x`.\n *\n * The standard normal distribution has `µ = 0` and `σ = 1`.\n * If x is standard normal, then `xσ + µ` is also normal with mean `µ` and standard deviation `σ`.\n * Conversely, if `y` is normal with mean `µ` and standard deviation `σ`, then `x = (y – µ) / σ` is\n * standard normal.\n *\n * `Y = normpdf(X)` uses the standard normal distribution (`µ = 0`, `σ = 1`).\n * `Y = normpdf(X,µ)` uses the normal distribution with unit standard deviation (`σ = 1`).\n *\n * @example normpdf({ data: [2, 1, 0, 1, 2], width: 5, height: 1 }, 0, 1.5) =>\n *   { data: [ 0.10934, 0.21297, 0.26596, 0.21297, 0.10934], width: 5, height: 1 }\n *\n * @method normpdf\n * @param {Matrix} X - The input matrix\n * @param {Number} [µ=0] - The length of the filter\n * @param {Number} [σ=1] - The filter sigma value\n * @returns {Matrix} Y - Returns the central part of the convolution of the same\n * size as `a`.\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function normpdf(\n  { data: ref, width, height }: Matrix,\n  µ = 0,\n  σ = 1\n): Matrix {\n  // data = ((2 * pi)^(-1 / 2)) * exp(-((x - µ) / σ)^2 / 2) / σ;\n  const SQ2PI = 2.506628274631000502415765284811\n  const data = new Array(ref.length)\n\n  for (let i = 0; i < ref.length; i++) {\n    const z = (ref[i] - µ) / σ\n\n    data[i] = Math.exp(-(z ** 2) / 2) / (σ * SQ2PI)\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n","import { Matrix } from '../types'\nimport { numbers } from './internal/numbers'\n\n/**\n * Create a matrix of all ones\n *\n * This method mimics Matlab's `ones` method\n *\n * @method ones\n * @param {Number} height - The height of the matrix (rows)\n * @param {Number} [width=height] - The width of the matrix (columns)\n * @returns {Matrix} B - An n-by-m matrix of ones\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function ones(height: number, width: number = height): Matrix {\n  return numbers(height, width, 1)\n}\n","import { Matrix } from '../types'\nimport { mod } from './mod'\n\n/**\n * Mirrors a matrix horizontally.\n *\n * @example\n * 1 2 3 4  becomes:  4 3 2 1\n * 5 6 7 8            8 7 6 5\n *\n * @method mirrorHorizonal\n * @param {Matrix} A - The input matrix\n * @returns {Matrix} B - The rotated matrix\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction mirrorHorizonal({ data: ref, width, height }: Matrix): Matrix {\n  const data = new Array(ref.length)\n\n  for (let x = 0; x < height; x++) {\n    for (let y = 0; y < width; y++) {\n      data[x * width + y] = ref[x * width + width - 1 - y]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Mirrors a matrix vertically.\n *\n * @example\n * 1 2 3 4  becomes:  9 0 F E\n * 5 6 7 8            5 6 7 8\n * 9 0 F E            1 2 3 4\n *\n * @method mirrorVertical\n * @param {Matrix} A - The input matrix\n * @returns {Matrix} B - The rotated matrix\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction mirrorVertical({ data: ref, width, height }: Matrix): Matrix {\n  const data = new Array(ref.length)\n\n  for (let x = 0; x < height; x++) {\n    for (let y = 0; y < width; y++) {\n      data[x * width + y] = ref[(height - 1 - x) * width + y]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Concatenates 2 matrices of the same height horizontally.\n *\n * @example\n * 1 2   3 4  becomes:  1 2 3 4\n * 5 6   7 8            5 6 7 8\n *\n * @method concatHorizontal\n * @param {Matrix} A - The first matrix\n * @param {Matrix} B - The second matrix\n * @returns {Matrix} out - The combined matrix\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction concatHorizontal(A: Matrix, B: Matrix): Matrix {\n  const width = A.width + B.width\n  const data = new Array(A.height * width)\n\n  for (let x = 0; x < A.height; x++) {\n    for (let y = 0; y < A.width; y++) {\n      data[x * width + y] = A.data[x * A.width + y]\n    }\n    for (let y = 0; y < B.width; y++) {\n      data[x * width + y + A.width] = B.data[x * B.width + y]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height: A.height,\n  }\n}\n\n/**\n * Concatenates 2 matrices of the same height vertically.\n *\n * @example\n * 1 2   3 4  becomes:  1 2\n * 5 6   7 8            5 6\n *                      3 4\n *                      7 8\n *\n * @method concatVertical\n * @param {Matrix} A - The first matrix\n * @param {Matrix} B - The second matrix\n * @returns {Matrix} out - The combined matrix\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction concatVertical(A: Matrix, B: Matrix): Matrix {\n  return {\n    data: A.data.concat(B.data),\n    height: A.height + B.height,\n    width: A.width,\n  }\n}\n\n/**\n * Adds 2 * `pad` cells to a matrix horizontally. The values used are mirrored from the input\n * matrix.\n *\n * @example\n * with padding 1:\n * 1 2 3 4   becomes:  1 1 2 3 4 4\n * 5 6 7 8             5 5 6 7 8 8\n *\n * With padding 2:\n * 1 2 3 4   becomes:  2 1 1 2 3 4 4 3\n * 5 6 7 8             6 5 5 6 7 8 8 7\n *\n * @method padHorizontal\n * @param {Matrix} A - The input matrix\n * @param {Number} pad - The nummber of cells to add to each side (left / right)\n * @returns {Matrix} B - The padded matrix\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction padHorizontal(A: Matrix, pad: number): Matrix {\n  const width = A.width + 2 * pad\n  const data = new Array(width * A.height)\n  const mirrored = concatHorizontal(A, mirrorHorizonal(A))\n\n  for (let x = 0; x < A.height; x++) {\n    for (let y = -pad; y < A.width + pad; y++) {\n      data[x * width + y + pad] =\n        mirrored.data[x * mirrored.width + mod(y, mirrored.width)]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height: A.height,\n  }\n}\n\n/**\n * Adds 2 * `pad` cells to a matrix vertically. The values used are mirrored from the input\n * matrix.\n *\n * @example\n * with padding 1:\n * 1 2 3 4   becomes:  1 2 3 4\n * 5 6 7 8             1 2 3 4\n *                     5 6 7 8\n *                     5 6 7 8\n * With padding 2:\n * 1 2 3 4   becomes:  5 6 7 8\n * 5 6 7 8             1 2 3 4\n *                     1 2 3 4\n *                     5 6 7 8\n *                     5 6 7 8\n *                     1 2 3 4\n *\n * @method padVertical\n * @param {Matrix} A - The input matrix\n * @param {Number} pad - The nummber of cells to add to each side (top / bottom)\n * @returns {Matrix} B - The padded matrix\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction padVertical(A: Matrix, pad: number): Matrix {\n  const mirrored = concatVertical(A, mirrorVertical(A))\n  const height = A.height + pad * 2\n  const data = new Array(A.width * height)\n\n  for (let x = -pad; x < A.height + pad; x++) {\n    for (let y = 0; y < A.width; y++) {\n      data[(x + pad) * A.width + y] =\n        mirrored.data[mod(x, mirrored.height) * A.width + y]\n    }\n  }\n\n  return {\n    data,\n    width: A.width,\n    height,\n  }\n}\n\n/**\n * Implements `padarray` matching Matlab only for the case where:\n *\n * `padHeight <= A.height && padWidth <= A.width`\n *\n * For an input Matrix `E`, we add padding A, B, C, D, F, G, H and I of size `padHeight` and\n * `padWidth` where appropriate. For instance, given E:\n *\n * 1 2 3\n * 4 5 6\n *\n * Placed in a padding matrix like this:\n *\n * | A | B | C |\n * |---|---|---|\n * | D | E | F |\n * |---|---|---|\n * | G | H | I |\n *\n * with padding [1, 1] it becomes:\n *\n * | 1 | 1 2 3 | 3 |\n * |---|-------|---|\n * | 1 | 1 2 3 | 3 |\n * | 4 | 4 5 6 | 6 |\n * |---|-------|---|\n * | 4 | 4 5 6 | 6 |\n *\n * with padding [2, 3] it becomes:\n *\n * | 6 5 4 | 4 5 6 | 6 5 4 |\n * | 3 2 1 | 1 2 3 | 3 2 1 |\n * |-------|-------|-------|\n * | 3 2 1 | 1 2 3 | 3 2 1 |\n * | 6 5 4 | 4 5 6 | 6 5 4 |\n * |-------|-------|-------|\n * | 6 5 4 | 4 5 6 | 6 5 4 |\n * | 3 2 1 | 1 2 3 | 3 2 1 |\n *\n * @method fastPadding\n * @param {Matrix} A - The input matrix\n * @param {Array<number>} padding - An array where the first element is the padding to apply to each\n * side on each row and the second one is the vertical padding for each side of each column\n * @returns {Matrix} B - The padded matrix\n * @private\n * @memberOf matlab\n * @since 0.0.4\n */\nfunction fastPadding(\n  A: Matrix,\n  [padHeight, padWidth]: [number, number]\n): Matrix {\n  const width = A.width + padWidth * 2\n  const height = A.height + padHeight * 2\n  const data = new Array(width * height)\n\n  for (let x = -padHeight; x < 0; x++) {\n    // A\n    for (let y = -padWidth; y < 0; y++) {\n      data[(x + padHeight) * width + y + padWidth] =\n        A.data[(Math.abs(x) - 1) * A.width + Math.abs(y) - 1]\n    }\n    // B\n    for (let y = 0; y < A.width; y++) {\n      data[(x + padHeight) * width + y + padWidth] =\n        A.data[(Math.abs(x) - 1) * A.width + y]\n    }\n    // C\n    for (let y = A.width; y < A.width + padWidth; y++) {\n      data[(x + padHeight) * width + y + padWidth] =\n        A.data[(Math.abs(x) - 1) * A.width + 2 * A.width - y - 1]\n    }\n  }\n\n  for (let x = 0; x < A.height; x++) {\n    // D\n    for (let y = -padWidth; y < 0; y++) {\n      data[(x + padHeight) * width + y + padWidth] =\n        A.data[x * A.width + Math.abs(y) - 1]\n    }\n    // E\n    for (let y = 0; y < A.width; y++) {\n      data[(x + padHeight) * width + y + padWidth] = A.data[x * A.width + y]\n    }\n    // F\n    for (let y = A.width; y < A.width + padWidth; y++) {\n      data[(x + padHeight) * width + y + padWidth] =\n        A.data[x * A.width + 2 * A.width - y - 1]\n    }\n  }\n\n  for (let x = A.height; x < A.height + padHeight; x++) {\n    // G\n    for (let y = -padWidth; y < 0; y++) {\n      data[(x + padHeight) * width + y + padWidth] =\n        A.data[(2 * A.height - x - 1) * A.width + Math.abs(y) - 1]\n    }\n    // H\n    for (let y = 0; y < A.width; y++) {\n      data[(x + padHeight) * width + y + padWidth] =\n        A.data[(2 * A.height - x - 1) * A.width + y]\n    }\n    // I\n    for (let y = A.width; y < A.width + padWidth; y++) {\n      data[(x + padHeight) * width + y + padWidth] =\n        A.data[(2 * A.height - x - 1) * A.width + 2 * A.width - y - 1]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\nexport type PaddingValue = 'symmetric'\nexport type PaddingDirection = 'both'\n/**\n * `B = padarray(A,padsize)` pads array `A`. padsize is a vector of nonnegative integers that\n * specifies both, the amount of padding to add and the dimension along which to add it. The value\n * of an element in the vector specifies the amount of padding to add. The order of the element in\n * the vector specifies the dimension along which to add the padding.\n *\n * For example, a padsize value of `[2 3]` means add 2 elements of padding along the first dimension\n * and 3 elements of padding along the second dimension.\n *\n * By default, paddarray adds padding before the first element and after the last element along the\n * specified dimension.\n *\n * `B = padarray(A,padsize,padval)` pads array `A` where `padval` specifies the value to use as the\n * pad value. `padval` can only be 'symmetric' for this implementation of `padarray` which will pad\n * the array with mirror reflections of itself.\n *\n * This method mimics Matlab's `padarray` method with `padval = 'symmetric'` and\n * `direction = 'both'`. No other options have been implemented and, if set, they will be ignored.\n *\n * This method has been unfolded for performance and switched to simple for loops. Readability\n * suffers.\n *\n * @method padarray\n * @param {Matrix} A - The target matrix\n * @param {Array<number>} padding - An array where the first element is the padding to apply to\n * each side on each row and the second one is the vertical padding for each side of each column\n * @param {String} [padval='symmetric'] - The type of padding to apply (coerced to 'symmetric')\n * @param {String} [direction='both'] - The direction to which apply padding (coerced to 'both')\n * @returns {Matrix} c - An array with padding added on each side.\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function padarray(\n  A: Matrix,\n  [padHeight, padWidth]: [number, number],\n  _padval?: PaddingValue,\n  _direction?: PaddingDirection\n): Matrix {\n  // If the padding to mirror is not greater than `A` dimensions, we can use `fastPadding`,\n  // otherwise we fall back to a slower implementation that mimics Matlab behavior for longer\n  // matrices\n  if (A.height >= padHeight && A.width >= padWidth) {\n    return fastPadding(A, [padHeight, padWidth])\n  }\n\n  return padVertical(padHorizontal(A, padWidth), padHeight)\n}\n","import { Matrix, ImageData } from '../types'\n\n/**\n * Converts an imageData object of { width, height, data } into a 2d matrix [row, column]\n * where the value is the grayscale equivalent of the rgb input.\n *\n * This method mimics Matlab's `rgb2gray` method\n *\n * @method rgb2gray\n * @param {Matrix | ImageData} imageData - The input imageData\n * @returns {Object} grayscale - A grayscale representation of the input image\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function rgb2gray({\n  data: d,\n  width,\n  height,\n}: Matrix | ImageData): Matrix {\n  const uint8Array = new Uint8Array(width * height)\n  for (let i = 0; i < d.length; i += 4) {\n    const grayIndex = i / 4\n    /**\n     * These values are not derived from ITU's recommendation of: [0.2126,\n     * 0.7152, 0.0722] for [r, g, b] but on Matlab's implementation of [0.2989,\n     * 0.5870, 0.1140]\n     *\n     * Note that values are rounded to ensure an exact match with the original\n     * results. Rounding them would NOT lead to higher accuracy since the exact\n     * values for RGB to grayscale conversion are somewhat arbitrary (as shown\n     * by the differences between ITU and Matlab).\n     *\n     * ± 0.5 pixel differences won't be perceptible for the human eye and will\n     * have a small impact on SSIM. Based on some sample data changes were of\n     * the order of 10^-3.\n     */\n    uint8Array[grayIndex] =\n      0.29894 * d[i] + 0.58704 * d[i + 1] + 0.11402 * d[i + 2] + 0.5\n  }\n  return {\n    data: Array.from(uint8Array),\n    width,\n    height,\n  }\n}\n\nexport function rgb2grayInteger({\n  data: d,\n  width,\n  height,\n}: Matrix | ImageData): Matrix {\n  const array = new Array(width * height)\n  for (let i = 0; i < d.length; i += 4) {\n    const grayIndex = i / 4\n    array[grayIndex] = (77 * d[i] + 150 * d[i + 1] + 29 * d[i + 2] + 128) >> 8\n  }\n  return {\n    data: array,\n    width,\n    height,\n  }\n}\n","import { Matrix } from '../types'\n\n/**\n * Generates a matrix based on input `mx` but excluding items based on their modulo and their\n * position in the original matrix.\n *\n * It's a crude implementation of Matlab's `A(1:f:end,1:f:end)` syntax where the first parameter\n * is the matrix, the next one is an array describing the rows to skip [start position, every `f`\n * elements an end position] and the last one follows the same syntax for columns.\n *\n * @example\n * ```\n * img1(1:f:end,1:f:end)\n *\n * ```\n *\n * becomes:\n *\n * ```\n * skip2d(img1, [0, f, img1.length], [0, f, img1[0].length])\n * ```\n *\n * Note that the start index is 0 since, unlike Matlab's, arrays start at 0. Also, unlike in Matlab,\n * `f` must be an integer greater than or equal to 1.\n *\n * @method skip2d\n * @param {Matrix} A - The input matrix\n * @param {Array<number>} - start row, every row, end row\n * @param {Array<number>} - start col, every col, end col\n * @returns {Matrix} B - The downsized matrix\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function skip2d(\n  A: Matrix,\n  [startRow, everyRow, endRow]: [number, number, number],\n  [startCol, everyCol, endCol]: [number, number, number]\n): Matrix {\n  const width = Math.ceil((endCol - startCol) / everyCol)\n  const height = Math.ceil((endRow - startRow) / everyRow)\n  const data = new Array(width * height)\n\n  for (let i = 0; i < height; i++) {\n    for (let j = 0; j < width; j++) {\n      const Ai = startRow + i * everyRow\n      const Aj = startCol + j * everyCol\n\n      data[i * width + j] = A.data[Ai * A.width + Aj]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n","import { Matrix } from '../types'\n\n/**\n * Crops the matrix and returns a window at position `[x,y]` of size `[xlen, ylen]` from the input\n * matrix\n *\n * @method sub\n * @param {Matrix} A - The input matrix\n * @param {Number} x - The starting x offset\n * @param {Number} height - The vertical size of the window\n * @param {Number} y - The starting y offset\n * @param {Number} width - The horizontal size of the window\n * @returns {Matrix} B - The generated subwindow from matrix `c`\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function sub(\n  { data: ref, width: refWidth }: Matrix,\n  x: number,\n  height: number,\n  y: number,\n  width: number\n): Matrix {\n  const data = new Array(width * height)\n\n  for (let i = 0; i < height; i++) {\n    for (let j = 0; j < width; j++) {\n      data[i * width + j] = ref[(y + i) * refWidth + x + j]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n","import { Matrix } from '../types'\n\n/**\n * Transposes a vector or a matrix\n *\n * This method mimics Matlab's `transpose` method (which equals to the `A.'` syntax)\n *\n * `B = A.'` returns the nonconjugate transpose of A, that is, interchanges the row and column index\n * for each element.\n *\n * This method does not handle complex or imaginary numbers\n *\n * @method transpose\n * @param {Matrix} A - The matrix to transpose\n * @returns {Matrix} B - The transposed matrix\n * @public\n * @memberOf matlab\n */\nexport function transpose({ data: ref, width, height }: Matrix): Matrix {\n  const data = new Array(width * height)\n\n  for (let i = 0; i < height; i++) {\n    for (let j = 0; j < width; j++) {\n      data[j * height + i] = ref[i * width + j]\n    }\n  }\n\n  return {\n    data,\n    height: width,\n    width: height,\n  }\n}\n","import { Matrix } from '../types'\nimport { numbers } from './internal/numbers'\n\n/**\n * Create a matrix of all zeros\n *\n * This method mimics Matlab's `zeros` method\n *\n * @method zeros\n * @param {Number} height - The height of the matrix (rows)\n * @param {Number} [width=height] - The width of the matrix (columns)\n * @returns {Matrix} B - An n-by-m matrix of zeros\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function zeros(height: number, width: number = height): Matrix {\n  return numbers(height, width, 0)\n}\n","/* eslint-disable max-statements */\n// Exceeding max-statements to preserve the structure of the original Matlab script\nimport {\n  add2d,\n  divide2d,\n  multiply2d,\n  square2d,\n  subtract2d,\n  sum2d,\n} from './math'\nimport { filter2, fspecial } from './matlab'\nimport { Options, Matrix } from './types'\n\n/**\n * Generates a SSIM map based on two input image matrices. For images greater than 512 pixels, it\n * will downsample them.\n *\n * Images must be a 2-Dimensional grayscale image\n *\n * This method is a line-by-line port of `assets/ssim.m`. Some operations are more verbose here\n * since more logic is needed in JS to manipulate matrices than in Matlab\n *\n * Note that setting `options1.k1` and `options.k2` to 0 will generate the UQI (Universal Quality\n * Index), since it's a special case of SSIM. In general that's undesierable since `k1` and `k2`\n * contribute to the stabilization coeficients `c1` and `c2`.\n *\n * For a mathematically equivalent and more efficient implementation check `./ssim.js`.\n *\n * @method originalSsim\n * @param {Matrix} pixels1 - The reference matrix\n * @param {Matrix} pixels2 - The second matrix to compare against\n * @param {Object} options - The input options parameter\n * @returns {Matrix} ssim_map - A matrix containing the map of computed SSIMs\n * @public\n * @memberOf ssim\n * @since 0.0.2\n */\nexport function originalSsim(\n  pixels1: Matrix,\n  pixels2: Matrix,\n  options: Options\n): Matrix {\n  let w = fspecial('gaussian', options.windowSize, 1.5)\n  const L = 2 ** options.bitDepth - 1\n  const c1 = (options.k1 * L) ** 2\n  const c2 = (options.k2 * L) ** 2\n\n  w = divide2d(w, sum2d(w))\n\n  const μ1 = filter2(w, pixels1, 'valid')\n  const μ2 = filter2(w, pixels2, 'valid')\n  const μ1Sq = square2d(μ1)\n  const μ2Sq = square2d(μ2)\n  const μ12 = multiply2d(μ1, μ2)\n  const pixels1Sq = square2d(pixels1)\n  const pixels2Sq = square2d(pixels2)\n  const σ1Sq = subtract2d(filter2(w, pixels1Sq, 'valid'), μ1Sq)\n  const σ2Sq = subtract2d(filter2(w, pixels2Sq, 'valid'), μ2Sq)\n  const σ12 = subtract2d(filter2(w, multiply2d(pixels1, pixels2), 'valid'), μ12)\n\n  if (c1 > 0 && c2 > 0) {\n    const num1 = add2d(multiply2d(μ12, 2), c1)\n    const num2 = add2d(multiply2d(σ12, 2), c2)\n    const denom1 = add2d(add2d(μ1Sq, μ2Sq), c1)\n    const denom2 = add2d(add2d(σ1Sq, σ2Sq), c2)\n\n    return divide2d(multiply2d(num1, num2), multiply2d(denom1, denom2))\n  }\n\n  const numerator1 = multiply2d(μ12, 2)\n  const numerator2 = multiply2d(σ12, 2)\n  const denominator1 = add2d(μ1Sq, μ2Sq)\n  const denominator2 = add2d(σ1Sq, σ2Sq)\n\n  return divide2d(\n    multiply2d(numerator1, numerator2),\n    multiply2d(denominator1, denominator2)\n  )\n}\n","/**\n * Implements all ssim-specific logic.\n *\n * Reproduces the original SSIM matlab scripts. For a direct comparison you may want to check the\n * scripts contained within `/assets`\n *\n * @namespace ssim\n */\nimport {\n  add2d,\n  divide2d,\n  multiply2d,\n  square2d,\n  subtract2d,\n  sum2d,\n} from './math'\nimport { conv2, normpdf, transpose } from './matlab'\nimport { Options, Matrix } from './types'\n\n/**\n * Generates a SSIM map based on two input image matrices. For images greater than 512 pixels, it\n * will downsample by default (unless `options.downsample` is set to falsy).\n *\n * Images must be a 2-Dimensional grayscale image\n *\n * This method produces the same exact output than `assets/ssim.m` when running on Matlab. It's\n * mathematically equivalent but it is not a line-by-line port. If you want a line-by-line port\n * check `originalSsim`. Several performance optimizations have been made here to achieve greater\n * performance.\n *\n * @method ssim\n * @param {Matrix} pixels1 - The reference matrix\n * @param {Matrix} pixels2 - The second matrix to compare against\n * @param {Options} options - The input options parameter\n * @returns {Matrix} ssim_map - A matrix containing the map of computed SSIMs\n * @public\n * @memberOf ssim\n */\nexport function ssim(\n  pixels1: Matrix,\n  pixels2: Matrix,\n  options: Options\n): Matrix {\n  let w = normpdf(getRange(options.windowSize), 0, 1.5)\n  const L = 2 ** options.bitDepth - 1\n  const c1 = (options.k1 * L) ** 2\n  const c2 = (options.k2 * L) ** 2\n\n  w = divide2d(w, sum2d(w))\n  const wt = transpose(w)\n  const μ1 = conv2(pixels1, w, wt, 'valid')\n  const μ2 = conv2(pixels2, w, wt, 'valid')\n  const μ1Sq = square2d(μ1)\n  const μ2Sq = square2d(μ2)\n  const μ12 = multiply2d(μ1, μ2)\n  const pixels1Sq = square2d(pixels1)\n  const pixels2Sq = square2d(pixels2)\n  const σ1Sq = subtract2d(conv2(pixels1Sq, w, wt, 'valid'), μ1Sq)\n  const σ2Sq = subtract2d(conv2(pixels2Sq, w, wt, 'valid'), μ2Sq)\n  const σ12 = subtract2d(\n    conv2(multiply2d(pixels1, pixels2), w, wt, 'valid'),\n    μ12\n  )\n\n  if (c1 > 0 && c2 > 0) {\n    return genSSIM(μ12, σ12, μ1Sq, μ2Sq, σ1Sq, σ2Sq, c1, c2)\n  }\n  return genUQI(μ12, σ12, μ1Sq, μ2Sq, σ1Sq, σ2Sq)\n}\n\n/**\n * Generates a range of distances of size `2n+1` with increments of 1 and centered at 0.\n *\n * @example `getRange(2) => [2 1 0 1 2]\n * @method getRange\n * @param {Number} size - The maximum distance from the center\n * @returns {Matrix} out - The generated vector\n * @private\n * @memberOf ssim\n */\nfunction getRange(size: number): Matrix {\n  const offset = Math.floor(size / 2)\n  const data = new Array(offset * 2 + 1)\n\n  for (let x = -offset; x <= offset; x++) {\n    data[x + offset] = Math.abs(x)\n  }\n\n  return {\n    data,\n    width: data.length,\n    height: 1,\n  }\n}\n\n/**\n * Generates the ssim_map based on the intermediate values of the convolutions of the input with the\n * gaussian filter.\n *\n * These methods apply when K1 or K2 are not 0 (non UQI)\n *\n * @method genSSIM\n * @param {Matrix} μ12 - The cell-by cell multiplication of both images convolved\n * with the gaussian filter\n * @param {Matrix} σ12 - The convolution of cell-by cell multiplication of both\n * images minus μ12\n * @param {Matrix} μ1Sq - The convolution of image1 with the gaussian filter squared\n * @param {Matrix} μ2Sq - The convolution of image2 with the gaussian filter squared\n * @param {Matrix} σ1Sq - The convolution of image1^2, minus μ1Sq\n * @param {Matrix} σ2Sq - The convolution of image2^2, minus μ2Sq\n * @param {Number} c1 - The first stability constant\n * @param {Number} c2 - The second stability constant\n * @returns {Matrix} ssim_map - The generated map of SSIM values at each window\n * @private\n * @memberOf ssim\n */\nfunction genSSIM(\n  μ12: Matrix,\n  σ12: Matrix,\n  μ1Sq: Matrix,\n  μ2Sq: Matrix,\n  σ1Sq: Matrix,\n  σ2Sq: Matrix,\n  c1: number,\n  c2: number\n): Matrix {\n  const num1 = add2d(multiply2d(μ12, 2), c1)\n  const num2 = add2d(multiply2d(σ12, 2), c2)\n  const denom1 = add2d(add2d(μ1Sq, μ2Sq), c1)\n  const denom2 = add2d(add2d(σ1Sq, σ2Sq), c2)\n\n  return divide2d(multiply2d(num1, num2), multiply2d(denom1, denom2))\n}\n\n/**\n * Generates the Universal Quality Index (UQI) ssim_map based on the intermediate values of the\n * convolutions of the input with the gaussian filter.\n *\n * These methods apply when K1 or K2 are 0 (UQI)\n *\n * @method genUQI\n * @param {Matrix} μ12 - The cell-by cell multiplication of both images convolved\n * with the gaussian filter\n * @param {Matrix} σ12 - The convolution of cell-by cell multiplication of both\n * images minus μ12\n * @param {Matrix} μ1Sq - The convolution of image1 with the gaussian filter squared\n * @param {Matrix} μ2Sq - The convolution of image2 with the gaussian filter squared\n * @param {Matrix} σ1Sq - The convolution of image1^2, minus μ1Sq\n * @param {Matrix} σ2Sq - The convolution of image2^2, minus μ2Sq\n * @returns {Matrix} ssim_map - The generated map of SSIM values at each window\n * @private\n * @memberOf ssim\n */\nfunction genUQI(\n  μ12: Matrix,\n  σ12: Matrix,\n  μ1Sq: Matrix,\n  μ2Sq: Matrix,\n  σ1Sq: Matrix,\n  σ2Sq: Matrix\n): Matrix {\n  const numerator1 = multiply2d(μ12, 2)\n  const numerator2 = multiply2d(σ12, 2)\n  const denominator1 = add2d(μ1Sq, μ2Sq)\n  const denominator2 = add2d(σ1Sq, σ2Sq)\n\n  return divide2d(\n    multiply2d(numerator1, numerator2),\n    multiply2d(denominator1, denominator2)\n  )\n}\n","/**\n * Implements Dan Weber's ssim-specific logic.\n *\n * @namespace weberSsim\n */\nimport { ImageMatrix, MSSIMMatrix, Options } from './types'\n\nfunction edgeHandler(w: number, h: number, sumArray: any, matrixWidth: number) {\n  const rightEdge = sumArray[h * matrixWidth + w + 1]\n  const bottomEdge = sumArray[(h + 1) * matrixWidth + w]\n  const bottomRightEdge = sumArray[(h + 1) * matrixWidth + w + 1]\n  return { rightEdge, bottomEdge, bottomRightEdge }\n}\n\nexport function partialSumMatrix1(\n  pixels: ImageMatrix,\n  f: (v: number, x: number, y: number) => number\n) {\n  const { width, height, data } = pixels\n  const matrixWidth = width + 1\n  const matrixHeight = height + 1\n  const sumArray = new Int32Array(matrixWidth * matrixHeight)\n  for (let h = height - 1; h >= 0; --h) {\n    for (let w = width - 1; w >= 0; --w) {\n      const { rightEdge, bottomEdge, bottomRightEdge } = edgeHandler(\n        w,\n        h,\n        sumArray,\n        matrixWidth\n      )\n\n      sumArray[h * matrixWidth + w] =\n        f(data[h * width + w], w, h) + rightEdge + bottomEdge - bottomRightEdge\n    }\n  }\n  return { data: sumArray, height: matrixHeight, width: matrixWidth }\n}\n\nexport function partialSumMatrix2(\n  pixels1: ImageMatrix,\n  pixels2: ImageMatrix,\n  f: (a: number, b: number, x: number, y: number) => number\n) {\n  const { width, height, data: data1 } = pixels1\n  const { data: data2 } = pixels2\n  const matrixWidth = width + 1\n  const matrixHeight = height + 1\n  const sumArray = new Int32Array(matrixWidth * matrixHeight)\n  for (let h = height - 1; h >= 0; --h) {\n    for (let w = width - 1; w >= 0; --w) {\n      const { rightEdge, bottomEdge, bottomRightEdge } = edgeHandler(\n        w,\n        h,\n        sumArray,\n        matrixWidth\n      )\n      const offset = h * width + w\n      sumArray[h * matrixWidth + w] =\n        f(data1[offset], data2[offset], w, h) +\n        rightEdge +\n        bottomEdge -\n        bottomRightEdge\n    }\n  }\n  return { data: sumArray, height: matrixHeight, width: matrixWidth }\n}\n\nexport function windowMatrix(\n  sumMatrix: any,\n  windowSize: number,\n  divisor: number\n) {\n  const { width: matrixWidth, height: matrixHeight, data: sumArray } = sumMatrix\n  const imageWidth = matrixWidth - 1\n  const imageHeight = matrixHeight - 1\n  const windowWidth = imageWidth - windowSize + 1\n  const windowHeight = imageHeight - windowSize + 1\n  const windows = new Int32Array(windowWidth * windowHeight)\n  for (let h = 0; h < imageHeight; ++h) {\n    for (let w = 0; w < imageWidth; ++w) {\n      if (w < windowWidth && h < windowHeight) {\n        const sum =\n          // value at (w,h)\n          sumArray[matrixWidth * h + w] -\n          // value at (w+windowSize,h) == right side\n          sumArray[matrixWidth * h + w + windowSize] -\n          // value at (w,h+windowSize) == bottom side\n          sumArray[matrixWidth * (h + windowSize) + w] +\n          // value at (w+windowSize, h+windowSize) == bottomRight corner\n          sumArray[matrixWidth * (h + windowSize) + w + windowSize]\n\n        windows[h * windowWidth + w] = sum / divisor\n      }\n    }\n  }\n  return { height: windowHeight, width: windowWidth, data: windows }\n}\n\nexport function windowSums(pixels: ImageMatrix, windowSize: number) {\n  return windowMatrix(\n    partialSumMatrix1(pixels, (a) => a),\n    windowSize,\n    1\n  )\n}\n\nexport function windowVariance(\n  pixels: ImageMatrix,\n  sums: any,\n  windowSize: number\n) {\n  const varianceCalculation = (v: number) => v * v\n  const windowSquared = windowSize * windowSize\n  const varX = windowMatrix(\n    partialSumMatrix1(pixels, varianceCalculation),\n    windowSize,\n    1\n  )\n  for (let i = 0; i < sums.data.length; ++i) {\n    const mean = sums.data[i] / windowSquared\n    const sumSquares = varX.data[i] / windowSquared\n\n    const squareMeans = mean * mean\n    varX.data[i] = 1024 * (sumSquares - squareMeans)\n  }\n  return varX\n}\n\nexport function windowCovariance(\n  pixels1: ImageMatrix,\n  pixels2: ImageMatrix,\n  sums1: any,\n  sums2: any,\n  windowSize: number\n) {\n  const covarianceCalculation = (a: number, b: number) => a * b\n  const windowSquared = windowSize * windowSize\n  const covXY = windowMatrix(\n    partialSumMatrix2(pixels1, pixels2, covarianceCalculation),\n    windowSize,\n    1\n  )\n  for (let i = 0; i < sums1.data.length; ++i) {\n    covXY.data[i] =\n      1024 *\n      (covXY.data[i] / windowSquared -\n        (sums1.data[i] / windowSquared) * (sums2.data[i] / windowSquared))\n  }\n  return covXY\n}\n\n/**\n * Generates a SSIM map based on two input image matrices.\n * Weber SSIM is an SSIM algorithm that operates in linear time by building\n * partial sum arrays of values, variances, and covariances, making each lookup\n * performable in constant time and each variance calculation, only performed\n * once.\n *\n * Images must be a 2-Dimensional grayscale image.\n *\n * @method weberSsim\n * @param {ImageMatrix} pixels1 - The reference matrix\n * @param {ImageMatrix} pixels2 - The second matrix to compare against\n * @param {Options} options - The input options parameter\n * @returns {ImageMatrix} ssim_map - A matrix containing the map of computed\n * SSIMs\n * @public\n * @memberOf weberSsim\n */\nexport function weberSsim(\n  pixels1: ImageMatrix,\n  pixels2: ImageMatrix,\n  options: Options\n): MSSIMMatrix {\n  const { bitDepth, k1, k2, windowSize } = options\n  const L = 2 ** bitDepth - 1\n  const c1 = k1 * L * (k1 * L)\n  const c2 = k2 * L * (k2 * L)\n  const windowSquared = windowSize * windowSize\n  const pixels1Rounded = {\n    ...pixels1,\n    data: Int32Array.from(pixels1.data, (v) => v + 0.5),\n  }\n  const pixels2Rounded = {\n    ...pixels2,\n    data: Int32Array.from(pixels2.data, (v) => v + 0.5),\n  }\n  const sums1 = windowSums(pixels1Rounded, windowSize)\n  const variance1 = windowVariance(pixels1Rounded, sums1, windowSize)\n\n  const sums2 = windowSums(pixels2Rounded, windowSize)\n  const variance2 = windowVariance(pixels2Rounded, sums2, windowSize)\n  const covariance = windowCovariance(\n    pixels1Rounded,\n    pixels2Rounded,\n    sums1,\n    sums2,\n    windowSize\n  )\n  const size = sums1.data.length\n\n  let mssim = 0\n  const ssims = new Array(size)\n  for (let i = 0; i < size; ++i) {\n    const meanx = sums1.data[i] / windowSquared\n    const meany = sums2.data[i] / windowSquared\n    const varx = variance1.data[i] / 1024\n    const vary = variance2.data[i] / 1024\n    const cov = covariance.data[i] / 1024\n    const na = 2 * meanx * meany + c1\n    const nb = 2 * cov + c2\n    const da = meanx * meanx + meany * meany + c1\n    const db = varx + vary + c2\n    const ssim = (na * nb) / da / db\n    ssims[i] = ssim\n    if (i == 0) {\n      mssim = ssim\n    } else {\n      mssim = mssim + (ssim - mssim) / (i + 1)\n    }\n  }\n\n  return { data: ssims, width: sums1.width, height: sums1.height, mssim }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(607);\n"],"sourceRoot":""}